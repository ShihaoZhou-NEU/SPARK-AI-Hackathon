/**
 * @file update_readme.js
 * @description Automatically updates the README.md file with data from GitHub Issues.
 * It reads registration and submission issues from JSON files (generated by gh CLI),
 * generates Markdown tables, and replaces specific sections in the README.
 */

const fs = require('fs');
const path = require('path');

// Paths to necessary files
const readmePath = path.join(process.env.GITHUB_WORKSPACE, 'README.md');
const registrationsPath = process.env.REGISTRATIONS_PATH;
const submissionsPath = process.env.SUBMISSIONS_PATH;

/**
 * Parsing Configuration for Issues
 * Maps internal field keys to the search strings in the Issue Template.
 */
const REGISTRATION_FIELDS = {
  name: "Name [姓名]",
  contact: "ContactMethod [联系方式]",
  wantsTeam: "WantsTeam [组队意愿（是/否）]",
  comment: "Comment [备注]"
};

const SUBMISSION_FIELDS = {
  projectName: "ProjectName [项目名称]",
  description: "Brief description [一句话简介]",
  repoLink: "Github Repo Link [Github 地址]",
  // optional fields if needed later
  track: "Track [赛道]",
  techStack: "TechStack [技术栈]",
  fullDescription: "ProjectDescription [项目描述]",
  teamLead: "Team Lead [负责人]",
  wallet: "Team Wallet Address [团队钱包地址]",
  demoLink: "Demo Link [演示链接]"
};

/**
 * Full template prompts to strip out from the lines.
 * This helps avoiding the colon-in-description issue.
 */
const PROMPT_STRIPPERS = [
  "**ContactMethod [联系方式] (格式: Telegram: @username，微信: username，邮箱: email@example.com):**",
  "**ContactMethod [联系方式] (格式: Telegram: @username，微信: username，邮箱: email@example.com):",
  "**Wallet Address [钱包地址] (您在以太坊主网的钱包地址或 ENS 域名):**",
  "**Wallet Address [钱包地址] (您在以太坊主网的钱包地址或 ENS 域名):",
  "**Team Wallet Address [团队钱包地址] (用于接收奖金，以太坊主网地址或 ENS 域名):**",
  "**Team Wallet Address [团队钱包地址] (用于接收奖金，以太坊主网地址或 ENS 域名):"
];

/**
 * parser for Issue Body
 * Iterates through lines to separate content by Key.
 * @param {string} body - The issue body text
 * @param {Object} fieldMap - Object mapping internal keys to template strings
 * @returns {Object} Extracted data
 */
function parseIssueBody(body, fieldMap) {
  if (!body) return {};

  const lines = body.split(/\r?\n/);
  const data = {};
  let currentField = null;

  // Initialize all fields to empty string
  Object.keys(fieldMap).forEach(k => data[k] = '');

  for (let i = 0; i < lines.length; i++) {
    let line = lines[i].trim();
    if (line === '') {
      // If inside a field, preserve *paragraph* breaks? 
      // Usually table cells don't like multiple paragraphs unless <br>.
      // We'll append newline char to value and handle formatting later.
      if (currentField) data[currentField] += '\n';
      continue;
    }

    // Check if this line is a new field header
    let matchedKey = null;
    for (const [key, searchStr] of Object.entries(fieldMap)) {
      if (line.includes(searchStr)) {
        matchedKey = key;
        break;
      }
    }

    if (matchedKey) {
      currentField = matchedKey;

      // Extract value from the same line if exists
      // 1. Try to strip known full prompts
      let val = line;
      let stripped = false;
      for (const stripper of PROMPT_STRIPPERS) {
        if (val.includes(stripper)) {
          val = val.replace(stripper, '').trim();
          stripped = true;
          break;
        }
      }

      // 2. If not stripped by exact prompt, try generic colon split
      if (!stripped) {
        // Find the searchStr in the line
        const idx = val.indexOf(fieldMap[matchedKey]);
        if (idx !== -1) {
          // Start looking for colon AFTER the key
          const afterKey = val.substring(idx + fieldMap[matchedKey].length);
          // Find first colon in the remaining part
          const colonMatch = afterKey.match(/(:|：)/);
          if (colonMatch) {
            val = afterKey.substring(colonMatch.index + 1).trim();
          } else {
            // No colon found? Maybe the line IS just the key.
            // Or maybe like "**Key** Value"
            // Heuristic: if starts with ** and ends with **, it's a header.
            // If content remains, use it.
            // For now, let's assume if we matched the key, we take the rest.
            // If the afterKey starts with "**", strip it.
            val = afterKey.trim();
            if (val.startsWith('**')) val = val.substring(2);
            if (val.endsWith('**')) val = val.substring(0, val.length - 2);
            if (val.startsWith(':') || val.startsWith('：')) val = val.substring(1).trim();
          }
        }
      }

      // Clean up Markdown bolding if user left it
      val = val.replace(/^\*\*|\*\*$/g, '');

      if (val) {
        data[currentField] = val;
      }
    } else {
      // Not a header line, append to current field
      if (currentField) {
        // Detect if it is ANOTHER known field from a DIFFERENT map? 
        // No, we only care about fields in fieldMap. 
        // BUT we should avoid appending other headers if we are parsing partials?
        // No, parseIssueBody is called with specific map (Reg or Sub).
        // We should stop if we hit a line that looks like *any* header?
        // For now, simpler is better.
        if (data[currentField]) {
          data[currentField] += (data[currentField].endsWith('\n') ? '' : ' ') + line;
        } else {
          data[currentField] = line;
        }
      }
    }
  }

  // Post-process: Trim values
  for (const key in data) {
    if (typeof data[key] === 'string') {
      data[key] = data[key].trim();
    }
  }

  return data;
}

/**
 * Formats text for a Markdown table cell.
 * - Escapes pipe characters '|' to prevent breaking table structure.
 * - Replaces newlines with <br> tags for multi-line support within a cell.
 * @param {string} text - The input text
 * @returns {string} Formatted text safe for Markdown tables
 */
function formatCol(text) {
  if (!text) return '-';
  // Remove ** markers inside text if any
  // text = text.replace(/\*\*/g, ''); 
  return text.replace(/\|/g, '\\|').replace(/\r?\n/g, '<br>');
}

/**
 * Generates the Markdown table for Registrations.
 * Columns: Name, GitHub ID, Contact, WantsTeam, Comment, Link
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateRegistrationTable(issues) {
  // Define Table Header
  let table = '| 姓名 | GitHub ID | 联系方式 | 组队意愿 | 备注 | 更新资料 |\n';
  table += '| --------- | --------- | -------- | -------- | ---- | -------- |\n';

  // Return placeholder if list is empty
  if (!issues || issues.length === 0) {
    table += '| 待更新... | - | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach(issue => {
    const body = issue.body || '';
    const fields = parseIssueBody(body, REGISTRATION_FIELDS);

    const name = fields.name;
    const contact = fields.contact;
    const wantsTeam = fields.wantsTeam;
    const comment = fields.comment;

    const githubId = issue.author ? issue.author.login : 'unknown';
    const issueUrl = issue.url;

    table += `| ${formatCol(name)} | [@${githubId}](https://github.com/${githubId}) | ${formatCol(contact)} | ${formatCol(wantsTeam)} | ${formatCol(comment)} | [Link](${issueUrl}) |\n`;
  });

  return table;
}

/**
 * Generates the Markdown table for Project Submissions.
 * Columns: ProjectName, GitHub ID, Description, Repo Link, Date
 * @param {Array} issues - Array of issue objects
 * @returns {string} The complete Markdown table string
 */
function generateSubmissionTable(issues) {
  // Define Table Header
  let table = '| 项目名称 | GitHub ID | 项目描述 | 项目链接 | 提交时间 |\n';
  table += '| --------- | --------- | -------- | -------- | -------- |\n';

  if (!issues || issues.length === 0) {
    table += '| 待更新... | - | - | - | - |\n';
    return table;
  }

  // Iterate through issues and build rows
  issues.forEach(issue => {
    const body = issue.body || '';
    const fields = parseIssueBody(body, SUBMISSION_FIELDS);

    const projectName = fields.projectName;
    const description = fields.description || fields.fullDescription; // Fallback
    const repoLink = fields.repoLink;

    const githubId = issue.author ? issue.author.login : 'unknown';
    // Format date as YYYY-MM-DD
    const date = issue.createdAt ? issue.createdAt.split('T')[0] : '-';

    table += `| ${formatCol(projectName)} | [@${githubId}](https://github.com/${githubId}) | ${formatCol(description)} | [Repo](${repoLink}) | ${date} |\n`;
  });

  return table;
}

/**
 * Replaces a section of text between two markers with new content.
 * Used to inject the generated tables into specific spots in README.md.
 * @param {string} content - The original file content
 * @param {string} startMarker - The marker string indicating start of section
 * @param {string} endMarker - The marker string indicating end of section
 * @param {string} newContent - The new content to insert
 * @returns {string} The modified content
 */
function replaceSection(content, startMarker, endMarker, newContent) {
  const startIndex = content.indexOf(startMarker);
  const endIndex = content.indexOf(endMarker);

  if (startIndex === -1 || endIndex === -1) {
    console.warn(`Markers not found: ${startMarker}, ${endMarker}`);
    return content;
  }

  // Reconstruct file: Part before marker + Marker + New Content + Part after end marker
  // Note: We deliberately add newlines for formatting
  return content.substring(0, startIndex + startMarker.length) + '\n\n' + newContent + '\n' + content.substring(endIndex);
}

// --- Main Execution ---
try {
  // Read current README
  let readmeContent = fs.readFileSync(readmePath, 'utf8');

  // 1. Process Registrations Table
  if (fs.existsSync(registrationsPath)) {
    let registrations = JSON.parse(fs.readFileSync(registrationsPath, 'utf8'));
    console.log(`Found ${registrations.length} registrations.`);
    // Filter out issues that don't have body content or are clearly not valid?
    // For now trust the label.
    const regTable = generateRegistrationTable(registrations);
    readmeContent = replaceSection(readmeContent, '<!-- Registration start -->', '<!-- Registration end -->', regTable);
  } else {
    console.log('No registrations file found, skipping registration update.');
  }

  // 2. Process Submissions Table
  if (fs.existsSync(submissionsPath)) {
    let submissions = JSON.parse(fs.readFileSync(submissionsPath, 'utf8'));
    console.log(`Found ${submissions.length} submissions.`);
    const subTable = generateSubmissionTable(submissions);
    readmeContent = replaceSection(readmeContent, '<!-- Submission start -->', '<!-- Submission end -->', subTable);
  } else {
    console.log('No submissions file found, skipping submission update.');
  }

  // Write changes back to README
  fs.writeFileSync(readmePath, readmeContent);
  console.log('README.md updated successfully.');

} catch (error) {
  console.error('Error updating README:', error);
  process.exit(1);
}
